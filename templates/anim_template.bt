//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
//------------------------------------------------
//--- 010 Editor v6.0 Binary Template
//
//      File: Tutorial.bt
//   Authors: SweetScape Software
//   Version: 1.1
//   Purpose: Part of the tutorial for 
//            learning to write binary templates. 
//------------------------------------------------
LittleEndian();

struct vec4 { 
    float x;
    float y;
    float z;
    float w;
};
struct ivec4 { 
    int x;
    int y;
    int z;
    int w;
};
struct vec3 { 
    float x;
    float y;
    float z;
};
struct vec2 { 
    float x;
    float y;
};

struct HEADER {
    char MAGIC[4];
    unsigned int FileSize; // filesize in bytes
    struct VER {
        char v;
        char vMajor <format=decimal>;
        char vMinor <format=decimal>;
        char vRevision <format=decimal>;
    } version <read=ReadVersionBlock>;
    unsigned int flag;
    float duration;
    float frame_rate;
    unsigned int num_nodes;
    unsigned int num_samples;
} headerInfo<bgcolor=cLtBlue>;

struct TransKey {
    float FrameTime;
    vec3 Value <read=ReadVec3>;
};
struct RotKey {
    float FrameTime;
    vec4 Value <read=ReadVec4>;
};
struct ScaleKey {
    float FrameTime;
    vec3 Value <read=ReadVec3>;
};

local int i, j;

struct DataBlock {
    char MAGIC[4];
    for(j = 0; j < headerInfo.num_nodes; j++) {
        struct NODE {
            unsigned int node_flag;
    
            struct Translations {
                for (i = 0; i < headerInfo.num_samples; i++) {
                    if (i % 2 == 0) {
                        vec3 translations<bgcolor=cLtGreen,read=ReadVec3>;
                    } else {
                        vec3 translations<bgcolor=cDkGreen,read=ReadVec3>;
                    }
                }
            } translations;

            struct Rotations {
                for (i = 0; i < headerInfo.num_samples; i++) {
                    if (i % 2 == 0) {
                        vec4 rotations<bgcolor=cLtGreen,read=ReadVec4>;
                    } else {
                        vec4 rotations<bgcolor=cDkGreen,read=ReadVec4>;
                    }
                }
            } rotations;

            struct Scales {
                for (i = 0; i < headerInfo.num_samples; i++) {
                    if (i % 2 == 0) {
                        vec3 scales<bgcolor=cLtGreen>;
                    } else {
                        vec3 scales<bgcolor=cDkGreen>;
                    }
                }
            } scales;
        } node;
    }
} dataBlock;//<bgcolor=cLtGreen>;

char END[4] <bgcolor=cRed>;

// Custom read functions
string ReadVersionBlock( VER &d )
{
    string str;
    SPrintf( str, "v%d.%d.%d", d.vMajor, d.vMinor, d.vRevision );
    return str;
}
string ReadVec4( vec4 &v )
{
    string str;
    SPrintf( str, "[%.2f,%.2f,%.2f,%.2f]", v.x, v.y, v.z, v.w );
    return str;
}
string ReadIVec4( ivec4 &v )
{
    string str;
    SPrintf( str, "[%d,%d,%d,%d]", v.x, v.y, v.z, v.w );
    return str;
}
string ReadVec3( vec3 &v )
{
    string str;
    SPrintf( str, "[%.2f,%.2f,%.2f]", v.x, v.y, v.z );
    return str;
}
string ReadVec2( vec2 &v )
{
    string str;
    SPrintf( str, "[%.2f,%.2f]", v.x, v.y );
    return str;
}

/*
struct HEADER {
    int fileID <format=hex>;
    float version;
    int blockOffset[4];
    string description;
    if( version > 3.0 )
        int extraData;
} headerInfo <bgcolor=cLtBlue>;

// Pre-reading data using ReadInt
struct OPTION1 { int tag; uchar data[8]; };
struct OPTION2 { int tag; uint64 data; };
if( ReadInt( FTell() ) == 1 )
    struct OPTION1 opt1;
else
    struct OPTION2 opt2;

// Duplicate array
double value;
double value;
double value;

// Out-of-order reading using FSeek
local int pos;
local int i;
struct DATABLOCK {
    int dataID;
    uchar dataArray[16];
};
pos = FTell(); // save read position
for( i = 0; i < 4; i++ ) {
    FSeek( headerInfo.blockOffset[i] );
    DATABLOCK data <read=ReadDataBlock>;
}
FSeek( pos );  // restore read position

// Custom read function
string ReadDataBlock( DATABLOCK &d )
{
    string str;
    SPrintf( str, "ID = '%d'", d.dataID );
    return str;
}
*/